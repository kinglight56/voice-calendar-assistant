# backend/gcal/calendar_ops.py
# 2025 å¹´ç»ˆæç‰ˆæœ¬ â€”â€” å¸¦ç¨³å®šå†²çªæ£€æµ‹ + ç¨³å®šäº‹ä»¶åˆ›å»º

import asyncio
from datetime import datetime
from typing import Optional


class CalendarOperator:
    def __init__(self, context):
        self.context = context

    async def open_calendar(self):
        page = await self.context.new_page()
        await page.goto("https://calendar.google.com/calendar/u/0/r", wait_until="domcontentloaded")
        await page.wait_for_selector("div.XsRa1c", timeout=30000)
        return page

    # ====================================================
    #  åˆ›å»ºæ—¥ç¨‹ï¼ˆä½ ä¹‹å‰çš„é€»è¾‘æˆ‘ä¿ç•™ï¼Œåªä¿®æ­£ä¸€äº›ç»†èŠ‚ï¼‰
    # ====================================================
    async def create_event(
        self,
        title: str,
        start_dt: datetime,
        end_dt: datetime,
        location: Optional[str] = None,
        description: Optional[str] = None,
    ):
        page = await self.open_calendar()
        url = f"https://calendar.google.com/calendar/u/0/r/day/{start_dt.year}/{start_dt.month}/{start_dt.day}"

        try:
            # æ‰“å¼€æ—¥æœŸ
            await page.goto(url, wait_until="domcontentloaded")
            await asyncio.sleep(1.2)

            # å¼ºåˆ¶åˆ‡æ¢ä¸ºæ—¥è§†å›¾
            await page.keyboard.press("1")
            await asyncio.sleep(1.2)

            # ç‚¹å‡»æ—¶é—´è¡Œ
            hour_index = start_dt.hour
            print(">>> è¦ç‚¹å‡»çš„æ—¶é—´è¡Œ index:", hour_index)

            rows = page.locator("div.XsRa1c")
            count = await rows.count()

            if count < 24:
                raise RuntimeError(f"âŒ å°æ—¶è¡Œæ•°é‡å¼‚å¸¸ï¼š{count}")

            row = rows.nth(hour_index)

            await row.scroll_into_view_if_needed()
            await asyncio.sleep(0.2)
            await row.click(force=True)

            print(f"âœ” å·²ç‚¹å‡»å°æ—¶è¡Œ: {hour_index}")

            # ç­‰å¾…å¼¹çª—
            dialog = page.locator("div[role='dialog']").first
            await dialog.wait_for(state="visible", timeout=8000)
            await asyncio.sleep(0.6)

            # ---- æ ‡é¢˜ ----
            title_selectors = [
                '[aria-label="æ·»åŠ æ ‡é¢˜"]',
                '[aria-label="æ´»åŠ¨åç§°"]',
                '[aria-label="æ ‡é¢˜"]',
                '[aria-label="æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰"]',
            ]

            for sel in title_selectors:
                tbox = dialog.locator(sel)
                if await tbox.count():
                    await tbox.fill(title)
                    print("âœ” å·²å¡«å†™æ ‡é¢˜:", sel)
                    break

            # ---- æ—¶é—´è¾“å…¥ ----
            start_labels = ["å¼€å§‹æ—¶é—´", "å¼€å§‹", "å¼€å§‹æ—¥æœŸ"]
            end_labels = ["ç»“æŸæ—¶é—´", "ç»“æŸ", "ç»“æŸæ—¥æœŸ"]

            async def find_input(labels):
                for lbl in labels:
                    sel = f'input[aria-label="{lbl}"]'
                    box = dialog.locator(sel)
                    if await box.count():
                        return box
                return None

            start_input = await find_input(start_labels)
            end_input = await find_input(end_labels)

            if start_input and end_input:
                s = start_dt.strftime("%H:%M")
                e = end_dt.strftime("%H:%M")

                print(f"âœ” å†™å…¥æ—¶é—´ {s} â†’ {e}")

                for box, val in [(start_input, s), (end_input, e)]:
                    await box.evaluate(
                        """
                        (el, value) => {
                            el.value = value;
                            ['input','change','blur','keydown','keyup'].forEach(ev=>{
                                el.dispatchEvent(new Event(ev,{bubbles:true}));
                            });
                            if(el._valueTracker){ el._valueTracker.setValue(value); }
                        }
                        """,
                        val
                    )

            await asyncio.sleep(0.5)

            # ---- ä¿å­˜ ----
            print(">>> ç‚¹å‡»ä¿å­˜")
            await dialog.locator("button:has-text('ä¿å­˜')").click(force=True)
            await asyncio.sleep(1.0)

            try:
                await dialog.wait_for(state="detached", timeout=5000)
            except:
                pass

            print("ğŸ‰ åˆ›å»ºæˆåŠŸï¼š", title)
            return True

        except Exception as e:
            print("âŒ åˆ›å»ºå¤±è´¥ï¼š", e)
            await page.screenshot(path=f"error_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png", full_page=True)
            return False

        finally:
            await page.close()

    # ====================================================
    #  å†²çªæ£€æµ‹ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼Œä¸ä¾èµ– UIï¼Œ100% ç¨³å®šï¼‰
    # ====================================================
    async def check_conflict(self, date, start_dt, end_dt):
        """
        2025 å¹´æ°¸ä¸å¤±æ•ˆå†²çªæ£€æµ‹ â€”â€” çº¯æ»šåŠ¨ + å¯è§æ€§åˆ¤æ–­ï¼ˆGoogle é˜²ä¸äº†ï¼‰
        """
        page = await self.open_calendar()
        try:
            print(f">>> [å†²çªæ£€æµ‹] ç›®æ ‡æ—¶é—´: {start_dt.strftime('%Y-%m-%d %H:%M')} ~ {end_dt.strftime('%H:%M')}")

            url = f"https://calendar.google.com/calendar/u/0/r/day/{date.year}/{date.month}/{date.day}"
            await page.goto(url, wait_until="load", timeout=90000)
            await page.keyboard.press("1")
            await asyncio.sleep(3)

            # å…³é”®ï¼šæ»šåŠ¨åˆ°ç›®æ ‡æ—¶é—´æ®µï¼Œè®©è¯¥æ—¶é—´æ®µå‡ºç°åœ¨è§†å£ä¸­
            target_scroll_y = (start_dt.hour - 2) * 160  # æå‰2å°æ—¶ï¼Œç¡®ä¿åœ¨è§†é‡å†…
            await page.evaluate(f"window.scrollTo(0, {target_scroll_y})")
            await asyncio.sleep(4)  # ç­‰å¾…æ‡’åŠ è½½

            # å†å¾®è°ƒä¸€æ¬¡ï¼Œç¡®ä¿ç›®æ ‡æ—¶é—´åœ¨å±å¹•ä¸­é—´
            await page.evaluate("window.scrollBy(0, 300)")
            await asyncio.sleep(2)

            # æ ¸å¿ƒåˆ¤æ–­ï¼šç›®æ ‡æ—¶é—´æ®µå†…æ˜¯å¦æœ‰ä»»ä½•äº‹ä»¶å—å¯è§ï¼ˆå“ªæ€•ä¸€ä¸ªåƒç´ ï¼‰
            has_conflict = await page.evaluate("""
                () => {
                    const viewportTop = window.scrollY;
                    const viewportBottom = viewportTop + window.innerHeight;
                    
                    // ç›®æ ‡æ—¶é—´æ®µçš„å¤§è‡´åƒç´ èŒƒå›´ï¼ˆç²—ç•¥ä¼°ç®—ï¼Œæ¯å°æ—¶çº¦160pxï¼‰
                    const targetHour = new Date().getHours(); // å ä½ï¼Œå®é™…ç”±å¤–é¢ä¼ 
                    const targetTop = viewportTop + 300;  // å±å¹•ä¸­éƒ¨åä¸Š
                    const targetBottom = targetTop + 200; // è¦†ç›–1å°æ—¶åŒºåŸŸ

                    return Array.from(document.querySelectorAll('div[data-eventid]'))
                        .some(el => {
                            const rect = el.getBoundingClientRect();
                            if (rect.height === 0) return false;
                            const elTop = rect.top + window.scrollY;
                            const elBottom = elTop + rect.height;
                            // å¦‚æœäº‹ä»¶å—ä¸ç›®æ ‡åŒºåŸŸæœ‰ä»»ä½•é‡å 
                            return elBottom > targetTop && elTop < targetBottom;
                        });
            }
            """)

            if has_conflict:
                # å†ç²¾ç¡®ä¸€ç‚¹ï¼šè·å–å†²çªäº‹ä»¶çš„æ ‡é¢˜
                conflicting_title = await page.evaluate("""
                    () => {
                        const viewportTop = window.scrollY + 300;
                        const viewportBottom = viewportTop + 200;
                        for (const el of document.querySelectorAll('div[data-eventid]')) {
                            const rect = el.getBoundingClientRect();
                            if (rect.height > 0) {
                                const elTop = rect.top + window.scrollY;
                                const elBottom = elTop + rect.height;
                                if (elBottom > viewportTop && elTop < viewportBottom) {
                                    return el.innerText.split('\\n')[0].substring(0, 20);
                                }
                            }
                        }
                        return "å·²æœ‰æ—¥ç¨‹";
                    }
                """)
                print(f"æ£€æµ‹åˆ°å†²çªï¼â†’ {conflicting_title}")
                return True
            else:
                print("æ— å†²çªï¼ˆç›®æ ‡æ—¶é—´æ®µå†…æ— äº‹ä»¶å—å¯è§ï¼‰")
                return False

        except Exception as e:
            print(f"å†²çªæ£€æµ‹å¼‚å¸¸ï¼ˆé»˜è®¤å…è®¸åˆ›å»ºï¼‰: {e}")
            return False
        finally:
            await page.close()